=== tests/cases/compiler/correctOrderOfPromiseMethod.ts ===
interface A {
>A : A

    id: string
>id : string
}

interface B {
>B : B

    id: string
>id : string

    fieldB: string
>fieldB : string
}

async function countEverything(): Promise<number> {
>countEverything : () => Promise<number>
>Promise : Promise<T>

    const providerA = async (): Promise<A[]> => { return [] }
>providerA : () => Promise<A[]>
>async (): Promise<A[]> => { return [] } : () => Promise<A[]>
>Promise : Promise<T>
>A : A
>[] : undefined[]

    const providerB = async (): Promise<B[]> => { return [] }
>providerB : () => Promise<B[]>
>async (): Promise<B[]> => { return [] } : () => Promise<B[]>
>Promise : Promise<T>
>B : B
>[] : undefined[]

    const [resultA, resultB] = await Promise.all([
>resultA : A[]
>resultB : B[]
>await Promise.all([        providerA(),        providerB(),    ]) : [A[], B[]]
>Promise.all([        providerA(),        providerB(),    ]) : Promise<[A[], B[]]>
>Promise.all : { <TAll>(values: Iterable<TAll>): Promise<(awaited TAll)[]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7, awaited T8, awaited T9, awaited T10]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1, T2, T3, T4, T5, T6, T7, T8, T9]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7, awaited T8, awaited T9]>; <T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1, T2, T3, T4, T5, T6, T7, T8]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7, awaited T8]>; <T1, T2, T3, T4, T5, T6, T7>(values: [T1, T2, T3, T4, T5, T6, T7]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7]>; <T1, T2, T3, T4, T5, T6>(values: [T1, T2, T3, T4, T5, T6]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6]>; <T1, T2, T3, T4, T5>(values: [T1, T2, T3, T4, T5]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5]>; <T1, T2, T3, T4>(values: [T1, T2, T3, T4]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4]>; <T1, T2, T3>(values: [T1, T2, T3]): Promise<[awaited T1, awaited T2, awaited T3]>; <T1, T2>(values: [T1, T2]): Promise<[awaited T1, awaited T2]>; <T>(values: T[]): Promise<(awaited T)[]>; }
>Promise : PromiseConstructor
>all : { <TAll>(values: Iterable<TAll>): Promise<(awaited TAll)[]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7, awaited T8, awaited T9, awaited T10]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1, T2, T3, T4, T5, T6, T7, T8, T9]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7, awaited T8, awaited T9]>; <T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1, T2, T3, T4, T5, T6, T7, T8]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7, awaited T8]>; <T1, T2, T3, T4, T5, T6, T7>(values: [T1, T2, T3, T4, T5, T6, T7]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6, awaited T7]>; <T1, T2, T3, T4, T5, T6>(values: [T1, T2, T3, T4, T5, T6]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5, awaited T6]>; <T1, T2, T3, T4, T5>(values: [T1, T2, T3, T4, T5]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4, awaited T5]>; <T1, T2, T3, T4>(values: [T1, T2, T3, T4]): Promise<[awaited T1, awaited T2, awaited T3, awaited T4]>; <T1, T2, T3>(values: [T1, T2, T3]): Promise<[awaited T1, awaited T2, awaited T3]>; <T1, T2>(values: [T1, T2]): Promise<[awaited T1, awaited T2]>; <T>(values: T[]): Promise<(awaited T)[]>; }
>[        providerA(),        providerB(),    ] : [Promise<A[]>, Promise<B[]>]

        providerA(),
>providerA() : Promise<A[]>
>providerA : () => Promise<A[]>

        providerB(),
>providerB() : Promise<B[]>
>providerB : () => Promise<B[]>

    ]);

    const dataA: A[] = resultA;
>dataA : A[]
>A : A
>resultA : A[]

    const dataB: B[] = resultB;
>dataB : B[]
>B : B
>resultB : B[]

    if (dataA && dataB) {
>dataA && dataB : B[]
>dataA : A[]
>dataB : B[]

        return dataA.length + dataB.length;
>dataA.length + dataB.length : number
>dataA.length : number
>dataA : A[]
>length : number
>dataB.length : number
>dataB : B[]
>length : number
    }
    return 0;
>0 : 0
}
